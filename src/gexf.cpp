/*
 * *gexf.cpp
 *
 *  Created on: Mar 27, 2020
 *      Author: heitzig
 */

/*
 * TODO:
 * - include metadata into gexf files
 */

#define BOOST_IOSTREAMS_NO_LIB

#include "global_variables.h"
#include "gexf.h"
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/filter/gzip.hpp>

unordered_map<string, bool> gexf_is_gz;
unordered_map<string, ofstream> gexf_direct, gexf_indirect;
unordered_map<string, boost::iostreams::filtering_streambuf<boost::iostreams::output>> gexf_buf;
ostream* gexf(NULL);
unordered_map<tricl::tricllink, timepoint> gexf_edge2start = {};

void init_gexf () {
    // open files:
    for (auto& [rat13, fn] : gexf_filename) {
        if ((fn != "") && (gexf_is_gz.count(fn)==0)) {
            auto ext = fn.substr(fn.find_last_of(".") + 1);
            if (ext == "gexf") {
                gexf_is_gz[fn] = false;
                gexf_direct[fn].open(fn);
            } else {
                gexf_is_gz[fn] = true;
                if (ext != "gz") throw "files:gexf must end with .gexf or .gexf.gz";
                gexf_indirect[fn] = ofstream(fn, std::ios_base::out | std::ios_base::binary | std::ios_base::trunc);
                gexf_buf[fn].push(boost::iostreams::gzip_compressor());
                gexf_buf[fn].push(gexf_indirect[fn]);
            }
        }
    }
    // output all nodes into all files:
    for (auto& [fn, is_gz] : gexf_is_gz) {
        if (fn != "") {
            if (is_gz) {
                ostream gexf_gz(&(gexf_buf[fn]));
                gexf = (ostream*)(&gexf_gz);
            } else {
                gexf = (ostream*)(&(gexf_direct[fn]));
            }
            *gexf << R"V0G0N(<?xml version="1.0" encoding="UTF-8"?>
<gexf xmlns="http://www.gexf.net/1.2draft" version="1.2" xmlns:viz="http://www.gexf.net/1.1draft/viz">
    <meta>
        <creator>tricl</creator>
        <description>dynamic graph generated by tricl model</description>
    </meta>
    <graph mode="dynamic" defaultedgetype="directed">
        <attributes class="node">
            <attribute id="T" title="entity type" type="string"/>
        </attributes>
        <attributes class="edge">
            <attribute id="R" title="relationship or action type" type="string"/>
            <attribute id="S" title="start" type="float"/>
            <attribute id="E" title="end" type="float"/>
        </attributes>
        <nodes>
)V0G0N";
            for (auto& e : es) {
                auto et = e2et[e];
                *gexf << "<node id=\"" << e << "\" label=\"" << e2label[e]
                     << "\" start=\"0.0\" end=\"" << max_t
                     << "\"><attvalues><attvalue for=\"T\" value=\""
                     << et2label[et] << "\"/></attvalues>";
                if (et2gexf_size.count(et) > 0) *gexf
                     << "<viz:size value=\"" << et2gexf_size[et] << "\"/>";
                if (et2gexf_shape.count(et) > 0) *gexf
                     << "<viz:shape value=\"" << et2gexf_shape[et] << "\"/>";
                if (et2gexf_r.count(et) > 0) *gexf
                     << "<viz:color r=\"" << et2gexf_r[et] << "\" g=\"" << et2gexf_g[et] << "\" b=\"" << et2gexf_b[et] << "\" a=\"" << et2gexf_a[et] << "\"/>";
                *gexf << "</node>" ;
            }
            *gexf << R"V0G0N(
        </nodes>
        <edges>
)V0G0N";
        }
    }
}

void gexf_output_edge (tricl::tricllink& l) {
    auto e1 = l.e1, e3 = l.e3;
    auto rat13 = l.rat13;
    if (rat13 != RT_ID) {
        string fn = gexf_filename[rat13];
        if (fn != "") {
            if (gexf_is_gz[fn]) {
                ostream gexf_gz(&(gexf_buf[fn]));
                gexf = (ostream*)(&gexf_gz);
            } else {
                gexf = (ostream*)(&(gexf_direct[fn]));
            }
            double start = gexf_edge2start.at(l), end = current_t;
            // unique edge id is <n_events>_<et1>_<rat13>_<et3>:
            *gexf << "\t\t\t<edge id=\"" << e1 << "_" << rat13 << "_" << e3 << "_" << n_events
                 << "\" source=\"" << e1
                 << "\" target=\"" << e3
                 << "\" start=\"" << start
                 << "\" end=\"" << end
                 << "\"><attvalues><attvalue for=\"R\" value=\"" << rat2label[rat13]
                 << "\"/><attvalue for=\"S\" value=\"" << start
                 << "\"/><attvalue for=\"E\" value=\"" << end
                 << "\"/></attvalues>";
            if (rat2gexf_thickness.count(rat13) > 0) *gexf
                 << "<viz:thickness value=\"" << rat2gexf_thickness[rat13] << "\"/>";
            if (rat2gexf_shape.count(rat13) > 0) *gexf
                 << "<viz:shape value=\"" << rat2gexf_shape[rat13] << "\"/>";
            if (rat2gexf_r.count(rat13) > 0) *gexf
                 << "<viz:color r=\"" << rat2gexf_r[rat13] << "\" g=\"" << rat2gexf_g[rat13] << "\" b=\"" << rat2gexf_b[rat13] << "\" a=\"" << rat2gexf_a[rat13] << "\"/>";
            *gexf << "</edge>" << endl;
        }
    }
    if (gexf_edge2start.erase(l) != 1) throw "ups";
}

void finish_gexf () {
    current_t = max_t;
    for (auto& [e1, outs] : e2outs) {
        for (auto& [rat13, e3] : outs) {
            tricl::tricllink l = { .e1 = e1, .rat13 = rat13, .e3 = e3 };
            if (rat13 != RT_ID) gexf_output_edge(l);
        }
    }
    // output footer to all files:
    for (auto& [fn, is_gz] : gexf_is_gz) {
        if (fn != "") {
            if (is_gz) {
                ostream gexf_gz(&(gexf_buf[fn]));
                gexf = (ostream*)(&gexf_gz);
            } else {
                gexf = (ostream*)(&(gexf_direct[fn]));
            }
            *gexf << R"V0G0N(        </edges>
    </graph>
</gexf>
)V0G0N";
            if (!is_gz) gexf_direct[fn].close();
        }
    }
}

